<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BluePiCast</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            font-size: 2rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        header h1 .icon {
            font-size: 2.5rem;
        }

        .status-bar {
            display: none;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff5722;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #4caf50;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .btn-primary {
            background: #0f3460;
            color: #e94560;
            border: 1px solid #e94560;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.3);
            background: #e94560;
            color: white;
            z-index: 10;
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.loading {
            opacity: 0.7;
            cursor: wait;
            pointer-events: none;
        }

        .btn-secondary {
            background: #16213e;
            color: #e4e4e4;
            border: 1px solid #0f3460;
        }

        .btn-secondary:hover {
            background: #0f3460;
            border-color: #e94560;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(244, 67, 54, 0.3);
            z-index: 10;
        }

        .btn-success {
            background: #4caf50;
            color: white;
        }

        .btn-success:hover {
            background: #388e3c;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
            z-index: 10;
        }

        .panels-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1024px) {
            .panels-container {
                grid-template-columns: 1fr;
            }
        }

        .devices-panel,
        .snapclient-panel {
            background: #16213e;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid #0f3460;
        }

        .panel-header {
            background: #0f3460;
            padding: 20px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-header h2 {
            color: #e4e4e4;
            font-size: 1.2rem;
            margin: 0;
        }

        .panel-header .controls {
            display: flex;
            gap: 10px;
        }

        .device-list {
            list-style: none;
        }

        .device-item {
            padding: 15px 20px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
        }

        .device-item:hover {
            background: #0f3460;
        }

        .device-item:last-child {
            border-bottom: none;
        }

        .device-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .device-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: #0f3460;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            border: 1px solid #e94560;
        }

        .device-details h3 {
            font-size: 1rem;
            color: #e4e4e4;
            margin-bottom: 5px;
        }

        .device-details .address {
            font-size: 0.85rem;
            color: #a0a0a0;
            font-family: monospace;
        }

        .device-details .status {
            font-size: 0.8rem;
            margin-top: 5px;
        }

        .device-details .status .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            margin-right: 5px;
        }

        .badge.paired {
            background: #e3f2fd;
            color: #1976d2;
        }

        .badge.connected {
            background: #e8f5e9;
            color: #388e3c;
        }

        .device-actions {
            display: flex;
            gap: 8px;
        }

        .device-actions .btn {
            padding: 8px 15px;
            font-size: 0.85rem;
        }

        .rssi-indicator {
            font-size: 0.8rem;
            color: #a0a0a0;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .rssi-bars {
            display: flex;
            gap: 2px;
            align-items: flex-end;
        }

        .rssi-bar {
            width: 4px;
            background: #ddd;
            border-radius: 2px;
        }

        .rssi-bar.active {
            background: #4caf50;
        }

        .empty-state {
            padding: 60px 20px;
            text-align: center;
            color: #a0a0a0;
        }

        .empty-state .icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state p {
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            font-weight: 500;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            background: #4caf50;
        }

        .toast.error {
            background: #f44336;
        }

        .toast.info {
            background: #2196f3;
        }

        .snapclient-content {
            padding: 20px;
            overflow: hidden;
        }

        .snapclient-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .snapclient-version {
            font-size: 0.9rem;
            color: #a0a0a0;
            font-family: monospace;
        }

        .snapclient-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .service-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .service-status.running {
            background: #0f3460;
            color: #4caf50;
            border: 1px solid #4caf50;
        }

        .service-status.stopped {
            background: #0f3460;
            color: #e94560;
            border: 1px solid #e94560;
        }

        .config-form {
            display: grid;
            gap: 15px;
            max-width: 100%;
            overflow: hidden;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 0;
            max-width: 100%;
        }

        .form-group label {
            font-weight: 600;
            color: #e4e4e4;
            font-size: 0.9rem;
        }

        .form-group input,
        .form-group select {
            padding: 10px;
            border: 1px solid #0f3460;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            background: #0f3460;
            color: #e4e4e4;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #e94560;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            header h1 {
                font-size: 1.5rem;
            }

            .status-bar {
                flex-direction: column;
                gap: 15px;
            }

            .device-item {
                flex-direction: column;
                gap: 15px;
                align-items: flex-start;
            }

            .device-actions {
                width: 100%;
                justify-content: flex-end;
            }

            .snapclient-controls {
                flex-wrap: wrap;
            }
        }

        .snapclient-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #0f3460;
        }

        .snapclient-tab {
            padding: 10px 20px;
            border: none;
            background: transparent;
            color: #a0a0a0;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }

        .snapclient-tab:hover {
            color: #e4e4e4;
            background: rgba(15, 52, 96, 0.3);
        }

        .snapclient-tab.active {
            color: #e94560;
            border-bottom-color: #e94560;
        }

        .snapclient-tab-content {
            display: none;
        }

        .snapclient-tab-content.active {
            display: block;
        }

        .logs-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #0f3460;
            border-radius: 8px;
        }

        .logs-container {
            background: #0a0a0a;
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #e4e4e4;
        }

        .logs-container::-webkit-scrollbar {
            width: 8px;
        }

        .logs-container::-webkit-scrollbar-track {
            background: #0f3460;
            border-radius: 4px;
        }

        .logs-container::-webkit-scrollbar-thumb {
            background: #e94560;
            border-radius: 4px;
        }

        .logs-container::-webkit-scrollbar-thumb:hover {
            background: #ff5a75;
        }

        .log-line {
            padding: 2px 0;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .logs-empty {
            color: #a0a0a0;
            text-align: center;
            padding: 50px 20px;
            font-style: italic;
        }

        .inspect-logs-btn {
            margin-left: 10px;
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {

            0%,
            100% {
                box-shadow: 0 0 5px rgba(233, 69, 96, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(233, 69, 96, 0.8);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>
                <span class="icon">üì°</span>
                BluePiCast
            </h1>
            <div class="connection-status">
                <div class="status-dot" id="wsStatus"></div>
                <span id="wsStatusText">Connecting...</span>
            </div>
        </header>

        <div class="panels-container">
            <!-- Bluetooth Panel -->
            <div class="devices-panel">
                <div class="panel-header">
                    <h2>üì± Bluetooth</h2>
                    <div class="controls">
                        <button class="btn btn-primary" id="scanBtn" onclick="startScan()">
                            <span id="scanBtnIcon">üîç</span>
                            <span id="scanBtnText">Scan</span>
                        </button>
                        <button class="btn btn-secondary" id="stopScanBtn" onclick="stopScan()" style="display: none;">
                            ‚èπÔ∏è Stop
                        </button>
                    </div>
                </div>
                <ul class="device-list" id="deviceList">
                    <li class="empty-state">
                        <div class="icon">üì°</div>
                        <p>No devices found yet</p>
                        <button class="btn btn-primary" onclick="startScan()">Start Scanning</button>
                    </li>
                </ul>
            </div>

            <!-- Snapclient Panel -->
            <div class="snapclient-panel" id="snapclientPanel" style="display: none;">
                <div class="panel-header">
                    <h2>üîä Snapcast Client</h2>
                </div>
                <div class="snapclient-content">
                    <!-- System Service Warning (shown as banner, doesn't hide config) -->
                    <div id="snapclientSystemWarning"
                        style="display: none; background: #ff6b6b; color: white; padding: 15px; margin-bottom: 15px; border-radius: 8px;">
                        <h3 style="margin-top: 0;">‚ö†Ô∏è System Service Detected</h3>
                        <p>Snapclient is running as a system service (as root). For better security and to allow control
                            from this UI, migrate it to a user service.</p>
                        <button class="btn btn-primary" onclick="migrateToUserService()"
                            style="background: white; color: #ff6b6b;">
                            üîß Migrate to User Service
                        </button>
                    </div>

                    <!-- User Service Not Enabled Warning -->
                    <div id="snapclientNotEnabledWarning"
                        style="display: none; background: #ffa726; color: white; padding: 15px; margin-bottom: 15px; border-radius: 8px;">
                        <h3 style="margin-top: 0;">‚ÑπÔ∏è User Service Not Enabled</h3>
                        <p>Configure Snapclient below, then enable the user service to start it.</p>
                        <button class="btn btn-primary" onclick="enableUserService()"
                            style="background: white; color: #ffa726;">
                            ‚úì Enable User Service
                        </button>
                    </div>

                    <!-- Normal UI (always shown now) -->
                    <div id="snapclientNormalUI">
                        <div class="snapclient-header">
                            <div>
                                <span class="service-status" id="snapclientServiceStatus">
                                    <span id="snapclientStatusDot">‚óè</span>
                                    <span id="snapclientStatusText">Unknown</span>
                                </span>
                                <div class="snapclient-version" id="snapclientVersion">Version: --</div>
                            </div>
                        </div>

                        <!-- Tab Navigation -->
                        <div class="snapclient-tabs">
                            <button class="snapclient-tab active" onclick="switchSnapclientTab('config')">‚öôÔ∏è
                                Configuration</button>
                            <button class="snapclient-tab" id="logsTab" onclick="switchSnapclientTab('logs')">üìã
                                Logs</button>
                        </div>

                        <!-- Configuration Tab -->
                        <div id="snapclientConfigTab" class="snapclient-tab-content active">
                            <div class="snapclient-controls">
                                <button class="btn btn-success" id="snapclientStartBtn" onclick="startSnapclient()">‚ñ∂
                                    Start</button>
                                <button class="btn btn-danger" id="snapclientStopBtn" onclick="stopSnapclient()">‚èπ
                                    Stop</button>
                                <button class="btn btn-primary" onclick="restartSnapclient()">üîÑ Restart</button>
                            </div>

                            <div class="config-form">
                                <div class="form-group">
                                    <label for="snapclientHost">Server Host:</label>
                                    <input type="text" id="snapclientHost" placeholder="127.0.0.1"
                                        oninput="markSnapclientFormModified()">
                                </div>
                                <div class="form-group">
                                    <label for="snapclientInstanceId">Instance ID (optional):</label>
                                    <input type="text" id="snapclientInstanceId" placeholder="my-snapclient"
                                        oninput="markSnapclientFormModified()">
                                </div>
                                <div class="form-group">
                                    <label for="snapclientPlayer">Player:</label>
                                    <select id="snapclientPlayer"
                                        onchange="markSnapclientFormModified(); checkAlsaAutoRouteAvailability(); toggleVolumeControl()">
                                        <option value="alsa">alsa</option>
                                        <option value="pipewire">pipewire</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="snapclientSoundcard">Soundcard (PCM Device, optional):</label>
                                    <select id="snapclientSoundcard"
                                        onchange="markSnapclientFormModified(); checkAlsaAutoRouteAvailability(); toggleVolumeControl(); checkSoundcardAvailability(); refreshVolumeForSoundcard()"
                                        disabled>
                                        <option value="">Loading...</option>
                                    </select>
                                </div>
                                <div class="form-actions">
                                    <button class="btn btn-primary" onclick="saveAndRestartSnapclient()">üíæ Save and
                                        Restart</button>
                                </div>
                                <div class="form-group"
                                    style="border-top: 1px solid #0f3460; padding-top: 15px; margin-top: 15px;">
                                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                                        <input type="checkbox" id="alsaAutoRoute" onchange="toggleAlsaAutoRoute()"
                                            style="width: 20px; height: 20px; cursor: pointer;">
                                        <span>Automatic Bluetooth ALSA Routing</span>
                                    </label>
                                    <small style="color: #a0a0a0; margin-top: 5px; display: block;">
                                        Automatically route audio to connected Bluetooth devices when player is "alsa"
                                        and soundcard is "bluealsa"
                                    </small>
                                </div>
                                <div class="form-group" id="volumeControlGroup" style="display: none;">
                                    <label for="snapclientVolume">
                                        Volume: <span id="volumeValue">100</span>%
                                    </label>
                                    <input type="range" id="snapclientVolume" min="0" max="100" value="100"
                                        style="width: 100%; cursor: pointer; accent-color: #e94560;"
                                        oninput="updateVolumeDisplay(this.value)" onchange="setAlsaVolume(this.value)">
                                </div>
                            </div>
                        </div> <!-- End snapclientConfigTab -->

                        <!-- Logs Tab -->
                        <div id="snapclientLogsTab" class="snapclient-tab-content">
                            <div class="logs-controls">
                                <label
                                    style="display: flex; align-items: center; gap: 10px; cursor: pointer; color: #e4e4e4;">
                                    <input type="checkbox" id="autoScrollCheckbox" checked
                                        style="width: 20px; height: 20px; cursor: pointer;">
                                    <span>Auto-scroll</span>
                                </label>
                                <button class="btn btn-secondary" onclick="clearLogs()">üóëÔ∏è Clear</button>
                            </div>
                            <div class="logs-container" id="logsContainer">
                                <div class="logs-empty">No logs yet. Logs will appear here when the service is running.
                                </div>
                            </div>
                        </div>

                    </div> <!-- End snapclientNormalUI -->
                </div>
            </div>
        </div>

        <div class="toast" id="toast"></div>

        <script>
            let ws = null;
            let reconnectTimeout = null;
            let isScanning = false;
            let snapclientEnabled = false;
            let pendingActions = new Map(); // Track ongoing actions by device address
            let snapclientStatusInterval = null; // Interval for checking Snapclient status
            let snapclientFormModified = false; // Track if user has modified the Snapclient form
            let pcmDevices = []; // Store PCM devices with availability information
            let pcmDevicesLoaded = false; // Track if PCM devices have been loaded
            let snapclientStatusLoaded = false; // Track if status has been loaded
            let currentVolume = null; // Track current volume to prevent unwanted resets
            let isRestarting = false; // Track if we're in the middle of a restart
            let logsActive = false; // Track if logs are being streamed
            let currentSnapclientTab = 'config'; // Track current tab

            function connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;

                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    updateConnectionStatus(true);
                    showToast('Connected to server', 'success');
                    // Request Snapclient PCM devices list after connection is established
                    requestSnapclientPCMDevices();
                    // Start log streaming immediately on page load, regardless of active tab
                    startLogStreaming();
                };

                ws.onclose = () => {
                    updateConnectionStatus(false);
                    scheduleReconnect();
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus(false);
                };

                ws.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        handleMessage(msg);
                    } catch (e) {
                        console.error('Error parsing message:', e);
                    }
                };
            }

            function scheduleReconnect() {
                if (reconnectTimeout) return;
                reconnectTimeout = setTimeout(() => {
                    reconnectTimeout = null;
                    connect();
                }, 3000);
            }

            function updateConnectionStatus(connected) {
                const dot = document.getElementById('wsStatus');
                const text = document.getElementById('wsStatusText');

                if (connected) {
                    dot.classList.add('connected');
                    text.textContent = 'Connected';
                } else {
                    dot.classList.remove('connected');
                    text.textContent = 'Disconnected - Reconnecting...';
                }
            }

            function handleMessage(msg) {
                switch (msg.type) {
                    case 'devices':
                        // Update scanning status first
                        updateScanningStatus(msg.payload.scanning);
                        // When not scanning, only show paired/connected devices
                        let devicesToShow = msg.payload.devices;
                        if (!msg.payload.scanning && devicesToShow) {
                            devicesToShow = devicesToShow.filter(d => d.paired || d.connected);
                        }
                        updateDeviceList(devicesToShow);
                        break;
                    case 'status':
                        updateScanningStatus(msg.payload.scanning);
                        if (msg.payload.message) {
                            showToast(msg.payload.message, 'info');
                        }
                        break;
                    case 'error':
                        // Only show error if it's not a Snapclient error when Snapclient is disabled
                        const errorMsg = msg.payload.message;
                        if (!snapclientEnabled && errorMsg && errorMsg.toLowerCase().includes('snapclient')) {
                            // Silently ignore Snapclient errors when feature is disabled
                            break;
                        }
                        showToast(errorMsg, 'error');
                        break;
                    case 'alsa_config':
                        updateAlsaConfig(msg.payload);
                        break;
                    case 'snapclient_status':
                        if (!snapclientEnabled) {
                            snapclientEnabled = true;
                            // Start polling for status updates
                            startSnapclientStatusPolling();
                        }
                        updateSnapclientStatus(msg.payload);
                        break;
                    case 'snapclient_players':
                        updateSnapclientPlayers(msg.payload);
                        break;
                    case 'snapclient_pcm_devices':
                        updateSnapclientPCMDevices(msg.payload);
                        break;
                    case 'snapclient_migration_result':
                        handleSnapclientMigrationResult(msg.payload);
                        break;
                    case 'snapclient_enable_result':
                        handleSnapclientEnableResult(msg.payload);
                        break;
                    case 'snapclient_set_volume':
                        // Handle volume response (also used when we request current volume)
                        if (msg.payload && msg.payload.volume !== undefined) {
                            const volumeSlider = document.getElementById('snapclientVolume');
                            if (volumeSlider) {
                                volumeSlider.value = msg.payload.volume;
                                updateVolumeDisplay(msg.payload.volume);
                            }
                        }
                        break;
                    case 'snapclient_log':
                        if (msg.payload && msg.payload.line) {
                            appendLogLine(msg.payload.line);
                        }
                        break;
                }
            }

            function updateDeviceList(devices) {
                const list = document.getElementById('deviceList');
                window.lastDevices = devices; // Store for re-rendering

                // Clear pending actions for devices that changed state
                if (devices) {
                    devices.forEach(device => {
                        if (pendingActions.has(device.address)) {
                            const action = pendingActions.get(device.address);
                            // Clear pending action if state changed as expected
                            if ((action === 'connect' || action === 'pair_and_connect') && device.connected) {
                                pendingActions.delete(device.address);
                            } else if (action === 'disconnect' && !device.connected) {
                                pendingActions.delete(device.address);
                            }
                        }
                    });
                }

                if (!devices || devices.length === 0) {
                    list.innerHTML = `
                    <li class="empty-state">
                        <div class="icon">üì°</div>
                        <p>No devices found yet</p>
                        <button class="btn btn-primary" onclick="startScan()">Start Scanning</button>
                    </li>
                `;
                    return;
                }

                // Sort: connected first, then paired, then by signal strength
                devices.sort((a, b) => {
                    if (a.connected !== b.connected) return b.connected - a.connected;
                    if (a.paired !== b.paired) return b.paired - a.paired;
                    return (b.rssi || -100) - (a.rssi || -100);
                });

                list.innerHTML = devices.map(device => `
                <li class="device-item" data-address="${escapeHtml(device.address)}">
                    <div class="device-info">
                        <div class="device-icon">${getDeviceIcon(device.icon)}</div>
                        <div class="device-details">
                            <h3>${escapeHtml(device.name || 'Unknown Device')}</h3>
                            <div class="address">${escapeHtml(device.address)}</div>
                            <div class="status">
                                ${device.paired ? '<span class="badge paired">Paired</span>' : ''}
                                ${device.connected ? '<span class="badge connected">Connected</span>' : ''}
                            </div>
                        </div>
                    </div>
                    <div class="rssi-indicator">
                        ${getRssiBars(device.rssi)}
                        <span>${device.rssi || '--'} dBm</span>
                    </div>
                    <div class="device-actions">
                        ${getDeviceActions(device)}
                    </div>
                </li>
            `).join('');
            }

            function getDeviceIcon(icon) {
                const icons = {
                    'audio-card': 'üîä',
                    'audio-headphones': 'üéß',
                    'audio-headset': 'üéß',
                    'camera-photo': 'üì∑',
                    'camera-video': 'üìπ',
                    'computer': 'üíª',
                    'input-gaming': 'üéÆ',
                    'input-keyboard': '‚å®Ô∏è',
                    'input-mouse': 'üñ±Ô∏è',
                    'input-tablet': 'üì±',
                    'modem': 'üì°',
                    'network-wireless': 'üì∂',
                    'phone': 'üì±',
                    'printer': 'üñ®Ô∏è',
                    'scanner': 'üì†',
                    'video-display': 'üñ•Ô∏è'
                };
                return icons[icon] || 'üì±';
            }

            function getRssiBars(rssi) {
                if (!rssi) return '';

                const strength = Math.min(4, Math.max(1, Math.floor((rssi + 100) / 20) + 1));
                let bars = '';
                for (let i = 1; i <= 4; i++) {
                    const height = 4 + (i * 3);
                    const active = i <= strength ? 'active' : '';
                    bars += `<div class="rssi-bar ${active}" style="height: ${height}px"></div>`;
                }
                return `<div class="rssi-bars">${bars}</div>`;
            }

            function getDeviceActions(device) {
                const safeAddress = escapeHtml(device.address);
                const isLoading = pendingActions.has(device.address);
                const loadingClass = isLoading ? ' loading' : '';
                const loadingText = isLoading ? '<div class="loading-spinner"></div>' : '';

                if (device.connected) {
                    let buttons = `<button class="btn btn-danger${loadingClass}" onclick="disconnect('${safeAddress}')" ${isLoading ? 'disabled' : ''}>${loadingText}${loadingText ? '' : 'Disconnect'}</button>`;

                    // Add "Set as Output" button for audio devices if conditions are met
                    if (isAudioDevice(device.icon) && canShowSetOutputButton()) {
                        buttons += `<button class="btn btn-primary" onclick="setAlsaOutput('${safeAddress}')" ${isLoading ? 'disabled' : ''}>Set as Output</button>`;
                    }

                    return buttons;
                }

                if (device.paired) {
                    return `
                    <button class="btn btn-success${loadingClass}" onclick="connectDevice('${safeAddress}')" ${isLoading ? 'disabled' : ''}>${loadingText}${loadingText ? '' : 'Connect'}</button>
                    <button class="btn btn-danger" onclick="removeDevice('${safeAddress}')" ${isLoading ? 'disabled' : ''}>Remove</button>
                `;
                }

                return `<button class="btn btn-primary${loadingClass}" onclick="pairAndConnect('${safeAddress}')" ${isLoading ? 'disabled' : ''}>${loadingText}${loadingText ? '' : 'Connect'}</button>`;
            }

            function isAudioDevice(icon) {
                const audioIcons = ['audio-card', 'audio-headphones', 'audio-headset', 'audio-speakers', 'multimedia-player', 'phone'];
                return audioIcons.includes(icon);
            }

            function canShowSetOutputButton() {
                // Only show if snapclient is enabled, auto-route is disabled, player is alsa, and soundcard is bluealsa
                if (!snapclientEnabled) return false;
                if (window.alsaAutoRoute) return false;

                const player = document.getElementById('snapclientPlayer')?.value;
                const soundcard = document.getElementById('snapclientSoundcard')?.value;

                return player === 'alsa' && soundcard === 'bluealsa';
            }

            function updateScanningStatus(scanning) {
                isScanning = scanning;
                const scanBtn = document.getElementById('scanBtn');
                const scanBtnIcon = document.getElementById('scanBtnIcon');
                const scanBtnText = document.getElementById('scanBtnText');
                const stopBtn = document.getElementById('stopScanBtn');

                if (scanning) {
                    scanBtn.disabled = true;
                    scanBtnIcon.innerHTML = '<div class="loading-spinner"></div>';
                    scanBtnText.textContent = 'Scanning...';
                    stopBtn.style.display = 'flex';
                } else {
                    scanBtn.disabled = false;
                    scanBtnIcon.textContent = 'üîç';
                    scanBtnText.textContent = 'Scan';
                    stopBtn.style.display = 'none';
                }
            }

            function send(type, payload) {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: type,
                        payload: payload
                    }));
                }
            }

            function startScan() {
                send('scan');
            }

            function stopScan() {
                send('stop_scan');
            }

            function pair(address) {
                send('pair', { address: address });
                showToast('Pairing with ' + address + '...', 'info');
            }

            function pairAndConnect(address) {
                pendingActions.set(address, 'pair_and_connect');
                updateDeviceList(getDevicesFromUI());
                send('pair_and_connect', { address: address });
                showToast('Connecting to ' + address + '...', 'info');
            }

            function connectDevice(address) {
                pendingActions.set(address, 'connect');
                updateDeviceList(getDevicesFromUI());
                send('connect', { address: address });
                showToast('Connecting to ' + address + '...', 'info');
            }

            function disconnect(address) {
                pendingActions.set(address, 'disconnect');
                updateDeviceList(getDevicesFromUI());
                send('disconnect', { address: address });
            }

            function removeDevice(address) {
                send('remove', { address: address });
            }

            // ALSA functions
            function updateAlsaConfig(config) {
                window.alsaAutoRoute = config.autoRoute;
                window.alsaCurrentDevice = config.currentDevice || '';

                const checkbox = document.getElementById('alsaAutoRoute');
                if (checkbox) {
                    checkbox.checked = config.autoRoute;
                }

                checkAlsaAutoRouteAvailability();

                // Re-render device list to update buttons
                if (window.lastDevices) {
                    updateDeviceList(window.lastDevices);
                }
            }

            function toggleAlsaAutoRoute() {
                const checkbox = document.getElementById('alsaAutoRoute');
                const autoRoute = checkbox.checked;

                send('alsa_set_config', { autoRoute: autoRoute });
                showToast(autoRoute ? 'Automatic ALSA routing enabled' : 'Automatic ALSA routing disabled', 'info');
            }

            function setAlsaOutput(address) {
                send('alsa_set_device', { address: address });
                showToast('Setting audio output to ' + address + '...', 'info');
            }

            function checkAlsaAutoRouteAvailability() {
                const checkbox = document.getElementById('alsaAutoRoute');
                if (!checkbox) return;

                const player = document.getElementById('snapclientPlayer')?.value;
                const soundcard = document.getElementById('snapclientSoundcard')?.value;

                // Enable checkbox only if player is "alsa" and soundcard is "bluealsa"
                const shouldEnable = player === 'alsa' && soundcard === 'bluealsa';
                checkbox.disabled = !shouldEnable;

                // Update label opacity to show disabled state
                const label = checkbox.parentElement;
                if (label) {
                    label.style.opacity = shouldEnable ? '1' : '0.5';
                    label.style.cursor = shouldEnable ? 'pointer' : 'not-allowed';
                }

                // Re-render device list to update "Set as Output" buttons
                if (window.lastDevices) {
                    updateDeviceList(window.lastDevices);
                }
            }

            function getDevicesFromUI() {
                // Helper to get current device list for re-rendering
                return Array.from(document.querySelectorAll('.device-item')).map(item => {
                    return window.lastDevices?.find(d => d.address === item.dataset.address);
                }).filter(Boolean);
            }

            function showToast(message, type) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = 'toast ' + type + ' show';

                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Snapclient functions
            function updateSnapclientStatus(status) {
                // Show the panel if we received status (means it's enabled)
                const panel = document.getElementById('snapclientPanel');
                panel.style.display = 'block';

                // Handle warnings (system service vs user service not enabled)
                const systemWarning = document.getElementById('snapclientSystemWarning');
                const notEnabledWarning = document.getElementById('snapclientNotEnabledWarning');
                const normalUI = document.getElementById('snapclientNormalUI');

                // Always show the normal UI now
                normalUI.style.display = 'block';

                if (status.isSystemService) {
                    // System service is running - show migration warning
                    systemWarning.style.display = 'block';
                    notEnabledWarning.style.display = 'none';
                } else if (!status.userServiceEnabled) {
                    // User service not enabled yet - show enable prompt
                    systemWarning.style.display = 'none';
                    notEnabledWarning.style.display = 'block';
                } else {
                    // Everything is good - user service is enabled
                    systemWarning.style.display = 'none';
                    notEnabledWarning.style.display = 'none';
                }

                const serviceStatus = document.getElementById('snapclientServiceStatus');
                const statusText = document.getElementById('snapclientStatusText');
                const versionText = document.getElementById('snapclientVersion');
                const startBtn = document.getElementById('snapclientStartBtn');
                const stopBtn = document.getElementById('snapclientStopBtn');
                const logsTab = document.getElementById('logsTab');

                // Remove any existing inspect logs button
                const existingInspectBtn = document.getElementById('inspectLogsBtn');
                if (existingInspectBtn) {
                    existingInspectBtn.remove();
                }

                if (status.running) {
                    serviceStatus.className = 'service-status running';
                    statusText.textContent = 'Running';
                    // Disable Start button, enable Stop button
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                } else if (status.failed) {
                    serviceStatus.className = 'service-status stopped';
                    statusText.textContent = 'Failed';
                    // Enable Start button, disable Stop button
                    startBtn.disabled = false;
                    stopBtn.disabled = true;

                    // Add "Inspect Logs" button next to the status
                    const inspectBtn = document.createElement('button');
                    inspectBtn.id = 'inspectLogsBtn';
                    inspectBtn.className = 'btn btn-danger inspect-logs-btn';
                    inspectBtn.textContent = 'üîç Inspect Logs';
                    inspectBtn.onclick = () => switchSnapclientTab('logs');
                    statusText.parentElement.appendChild(inspectBtn);
                } else {
                    serviceStatus.className = 'service-status stopped';
                    statusText.textContent = 'Stopped';
                    // Enable Start button, disable Stop button
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }

                if (status.version) {
                    versionText.textContent = 'Version: ' + status.version;
                }

                // Mark that status has been loaded (for enabling dropdown)
                if (status.config) {
                    snapclientStatusLoaded = true;
                }

                // Update form fields only if user hasn't modified them
                if (status.config && !snapclientFormModified) {
                    document.getElementById('snapclientHost').value = status.config.host || '';
                    document.getElementById('snapclientInstanceId').value = status.config.instanceId || '';

                    const playerSelect = document.getElementById('snapclientPlayer');
                    const playerValue = status.config.player || 'alsa';
                    playerSelect.value = playerValue;

                    const soundcardSelect = document.getElementById('snapclientSoundcard');
                    soundcardSelect.value = status.config.soundcard || '';

                    // Update volume slider only if not restarting or if we don't have a saved volume
                    if (status.config.volume !== undefined && !isRestarting) {
                        const volumeSlider = document.getElementById('snapclientVolume');
                        if (volumeSlider) {
                            volumeSlider.value = status.config.volume;
                            updateVolumeDisplay(status.config.volume);
                            currentVolume = status.config.volume;
                        }
                    } else if (isRestarting && currentVolume !== null) {
                        // Restore saved volume during restart
                        const volumeSlider = document.getElementById('snapclientVolume');
                        if (volumeSlider) {
                            volumeSlider.value = currentVolume;
                            updateVolumeDisplay(currentVolume);
                        }
                    }
                }

                // Enable dropdown only if both PCM devices and status are loaded
                const soundcardSelect = document.getElementById('snapclientSoundcard');
                if (soundcardSelect && pcmDevicesLoaded && snapclientStatusLoaded) {
                    soundcardSelect.disabled = false;
                }

                // Check if ALSA auto-route should be available and toggle volume control visibility
                checkAlsaAutoRouteAvailability();
                toggleVolumeControl();
                // Check soundcard availability from frontend (this will also use backend info if available)
                checkSoundcardAvailability();
            }

            function markSnapclientFormModified() {
                snapclientFormModified = true;
            }

            function updateSnapclientPlayers(players) {
                // This function is no longer used for player selection
                // Players are now fixed options (alsa, pipewire)
                // This is kept for backward compatibility
            }

            function updateSnapclientPCMDevices(devices) {
                // Store devices with availability information
                pcmDevices = devices || [];
                pcmDevicesLoaded = true;

                const select = document.getElementById('snapclientSoundcard');

                // Clear existing options properly
                while (select.firstChild) {
                    select.removeChild(select.firstChild);
                }

                // Add default option (always available)
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'default';
                select.appendChild(defaultOption);

                // Add PCM devices
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.name;
                    option.textContent = device.name + (device.description ? ' - ' + device.description : '');
                    select.appendChild(option);
                });

                // Enable dropdown only if both PCM devices and status are loaded
                if (pcmDevicesLoaded && snapclientStatusLoaded) {
                    select.disabled = false;
                }

                // Check availability of currently selected soundcard
                checkSoundcardAvailability();
            }

            function startSnapclient() {
                send('snapclient_start');
                showToast('Starting Snapclient service...', 'info');
            }

            function stopSnapclient() {
                send('snapclient_stop');
                showToast('Stopping Snapclient service...', 'info');
            }

            function restartSnapclient() {
                send('snapclient_restart');
                showToast('Restarting Snapclient service...', 'info');
            }

            function saveAndRestartSnapclient() {
                const config = {
                    host: document.getElementById('snapclientHost').value,
                    instanceId: document.getElementById('snapclientInstanceId').value,
                    player: document.getElementById('snapclientPlayer').value,
                    soundcard: document.getElementById('snapclientSoundcard').value
                };

                // Save current volume before restart
                const volumeSlider = document.getElementById('snapclientVolume');
                if (volumeSlider) {
                    currentVolume = parseInt(volumeSlider.value);
                }

                isRestarting = true;
                send('snapclient_set_config', config);
                showToast('Saving configuration and restarting...', 'info');
                // Reset the modified flag since we're saving
                snapclientFormModified = false;
                // Restart after a short delay to allow config to be saved
                setTimeout(() => {
                    send('snapclient_restart');
                    // Clear restarting flag after 5 seconds to allow status updates
                    setTimeout(() => {
                        isRestarting = false;
                    }, 5000);
                }, 500);
            }

            function requestSnapclientPlayers() {
                send('snapclient_get_players');
            }

            function requestSnapclientPCMDevices() {
                send('snapclient_get_pcm');
            }

            function requestSnapclientStatus() {
                send('snapclient_get_status');
            }

            function startSnapclientStatusPolling() {
                // Clear any existing interval
                if (snapclientStatusInterval) {
                    clearInterval(snapclientStatusInterval);
                }
                // Poll status every 5 seconds
                snapclientStatusInterval = setInterval(() => {
                    if (snapclientEnabled && ws && ws.readyState === WebSocket.OPEN) {
                        requestSnapclientStatus();
                    }
                }, 5000);
            }

            function enableUserService() {
                showToast('Enabling user service...', 'info');
                send('snapclient_enable_user_service');
            }

            function migrateToUserService() {
                if (!confirm('This will attempt to migrate Snapclient from a system service to a user service. Continue?')) {
                    return;
                }
                showToast('Starting migration...', 'info');
                send('snapclient_migrate');
            }

            function handleSnapclientMigrationResult(result) {
                if (result.success) {
                    showToast('Migration successful! Snapclient is now running as a user service.', 'success');
                } else if (result.manualSteps && result.manualSteps.length > 0) {
                    const steps = result.manualSteps.join('\n');
                    alert(result.error + '\n\n' + steps);
                    showToast('Migration requires manual steps. See alert for details.', 'warning');
                } else {
                    showToast('Migration failed: ' + (result.error || 'Unknown error'), 'error');
                }
            }

            function handleSnapclientEnableResult(result) {
                if (result.success) {
                    showToast('User service enabled successfully!', 'success');
                    requestSnapclientStatus();
                } else {
                    showToast('Failed to enable user service: ' + (result.error || 'Unknown error'), 'error');
                }
            }

            // Volume control functions
            function toggleVolumeControl() {
                const player = document.getElementById('snapclientPlayer')?.value;
                const volumeGroup = document.getElementById('volumeControlGroup');

                if (!volumeGroup) return;

                // Show volume control only when player is "alsa" (strictly)
                if (player === 'alsa') {
                    volumeGroup.style.display = 'flex';
                } else {
                    volumeGroup.style.display = 'none';
                }
            }

            function updateVolumeDisplay(volume) {
                const volumeValue = document.getElementById('volumeValue');
                if (volumeValue) {
                    volumeValue.textContent = volume;
                }
            }

            function setAlsaVolume(volume) {
                const vol = Number(volume);
                if (isNaN(vol) || vol < 0 || vol > 100) {
                    showToast('Invalid volume value', 'error');
                    return;
                }
                send('snapclient_set_volume', { volume: vol });
                showToast('Setting volume to ' + vol + '%...', 'info');
            }

            function checkSoundcardAvailability() {
                const player = document.getElementById('snapclientPlayer')?.value;
                const soundcard = document.getElementById('snapclientSoundcard')?.value;
                const volumeSlider = document.getElementById('snapclientVolume');

                if (!volumeSlider || player !== 'alsa') {
                    return; // Only check for ALSA player
                }

                // Check if soundcard is available in the PCM devices list
                let isAvailable = true;

                if (soundcard === '' || soundcard === 'default') {
                    // Default is always available
                    isAvailable = true;
                } else {
                    // Find the soundcard in the PCM devices list
                    const device = pcmDevices.find(d => d.name === soundcard);
                    if (device) {
                        isAvailable = device.available !== false; // Default to true if not specified
                    } else {
                        // If device not found in list, assume unavailable
                        isAvailable = false;
                    }
                }

                // Update slider state based on availability
                if (isAvailable) {
                    volumeSlider.disabled = false;
                    volumeSlider.style.opacity = '1';
                    volumeSlider.style.cursor = 'pointer';
                } else {
                    volumeSlider.disabled = true;
                    volumeSlider.style.opacity = '0.5';
                    volumeSlider.style.cursor = 'not-allowed';
                }
            }

            function refreshVolumeForSoundcard() {
                const player = document.getElementById('snapclientPlayer')?.value;
                const soundcard = document.getElementById('snapclientSoundcard')?.value;
                const volumeSlider = document.getElementById('snapclientVolume');

                // Only refresh for ALSA player with available soundcard
                if (player !== 'alsa' || !volumeSlider) {
                    return;
                }

                // Check if soundcard is available
                let isAvailable = true;
                if (soundcard === '' || soundcard === 'default') {
                    isAvailable = true;
                } else {
                    const device = pcmDevices.find(d => d.name === soundcard);
                    if (device) {
                        isAvailable = device.available !== false;
                    } else {
                        isAvailable = false;
                    }
                }

                // Only fetch volume if soundcard is available
                if (isAvailable) {
                    // Request volume from backend for this soundcard
                    send('snapclient_get_volume', { soundcard: soundcard });
                } else {
                    // Set to default volume if not available
                    volumeSlider.value = 100;
                    updateVolumeDisplay(100);
                }
            }

            // Snapclient tab switching functions
            function switchSnapclientTab(tabName) {
                currentSnapclientTab = tabName;

                // Update tab buttons
                const tabs = document.querySelectorAll('.snapclient-tab');
                tabs.forEach(tab => {
                    tab.classList.remove('active');
                });

                // Update tab content
                const configTab = document.getElementById('snapclientConfigTab');
                const logsTab = document.getElementById('snapclientLogsTab');

                if (tabName === 'config') {
                    configTab.classList.add('active');
                    logsTab.classList.remove('active');
                    tabs[0].classList.add('active');
                    // Log streaming remains active in background - no longer stopped when switching tabs
                } else if (tabName === 'logs') {
                    configTab.classList.remove('active');
                    logsTab.classList.add('active');
                    tabs[1].classList.add('active');
                    // Log streaming was started when panel was first shown and remains active
                }
            }

            function startLogStreaming() {
                if (logsActive) return;
                logsActive = true;
                send('snapclient_start_logs', {});
            }

            function stopLogStreaming() {
                if (!logsActive) return;
                logsActive = false;
                send('snapclient_stop_logs', {});
            }

            function appendLogLine(line) {
                const container = document.getElementById('logsContainer');

                // Remove empty state message if present
                const emptyState = container.querySelector('.logs-empty');
                if (emptyState) {
                    emptyState.remove();
                }

                // Create log line element
                const logLine = document.createElement('div');
                logLine.className = 'log-line';
                logLine.textContent = line;
                container.appendChild(logLine);

                // Auto-scroll if checkbox is checked
                const autoScroll = document.getElementById('autoScrollCheckbox');
                if (autoScroll && autoScroll.checked) {
                    container.scrollTop = container.scrollHeight;
                }

                // Limit number of log lines to prevent memory issues (keep last 1000)
                const logLines = container.querySelectorAll('.log-line');
                if (logLines.length > 1000) {
                    logLines[0].remove();
                }
            }

            function clearLogs() {
                const container = document.getElementById('logsContainer');
                container.innerHTML = '<div class="logs-empty">Logs cleared. New logs will appear here.</div>';
            }

            // Initialize
            connect();
        </script>
</body>

</html>